# -*- coding: utf-8 -*-
"""Jacob Askins Math 24 Lab 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zGqRiFSFcMzu9nsferK2lbsw33Dyz27_
"""

import matplotlib.pyplot as plt
from PIL import Image
import imageio.v2 as imageio

#Imports libraries for plotting, image processing, and reading/writing images.

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

#Displays an image `x` with grayscale colormap, no axes, in a large format.

im = imageio.imread('https://lospec.com/palette-list/st-64-natural-1x.png')

#Reads an image from a URL using `imageio` into variable `im`.

plot(im)

#This command would display the image im in a figure with grayscale coloring and no axes, using the previously defined plot function

im.shape
#Displays the shape of 'im'.

plot(im[:,40:41,:])

#Displays a slice of the image 'im' at the given coordinates.

im[:,40:41,:]

#Displays a slice of the image 'im' at the given coordinates as an array.

im = imageio.imread('https://lospec.com/palette-list/waverator-1x.png')

#Reads an image from a URL using `imageio` into variable `im`.

plot(im)

##This command would display the image im in a figure with grayscale coloring and no axes, using the previously defined plot function

im

#Displays the array of 'im'.



import numpy as np
import matplotlib.pyplot as plt

#This code imports the NumPy library for numerical operations and the Matplotlib library for plotting in Python.

# Binary image
binary_image = np.array([
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
])

#Generates a binary image, 0 being black and 1 being white.

binary_image

#displays the binary image as an array.

plt.imshow(binary_image, cmap='gray')

#Plots the binary image.

# Grayscale image
grayscale_image = np.array([
    [50, 100, 150],
    [200, 255, 200],
    [150, 100, 50]
])
plt.imshow(grayscale_image, cmap='gray', vmin=0, vmax=255)

#This code creates and displays a grayscale image from a 3x3 NumPy array, with pixel values ranging from 0 to 255.

# Grayscale image
grayscale_image = np.array([
    [0.2, 0.4, 0.6],
    [0.8, 1.0, 0.8],
    [0.6, 0.4, 0.2]
])
plt.imshow(grayscale_image, cmap='gray')

#Creates and displays a grayscale image with specified brightness values using matplotlib.

# RGB image
rgb_image = np.array([
    [[255, 0, 0], [0, 255, 0], [0, 0, 255]],
    [[255, 255, 0], [0, 255, 255], [255, 0, 255]],
    [[128, 128, 128], [255, 255, 255], [0, 0, 0]]
])

#Creates an RGB image with specific colors for each pixel using numpy arrays.

rgb_image

plt.imshow(rgb_image)

#Displays the RGB image created with numpy arrays using matplotlib's imshow function.

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],
    [[0.5, 0.5, 0.5], [1, 1, 1], [0, 0, 0]]
])

#Defines an RGB image with normalized color values ranging between 0 and 1.

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],

])

#Creates a 2-row RGB image with distinct colors in each pixel using numpy.

rgb_image

#Defines a numpy array representing a 2D RGB image with specific color pixels.

plt.imshow(rgb_image*255)

#Displays the RGB image, scaling color values to the full 0-255 range using matplotlib.



x = np.zeros((2,2,3))
x[:,:,0] = 1
plt.imshow(x)

#Creates a red image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,1] = 1
plt.imshow(x)

#Creates a green image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,2] = 1
plt.imshow(x)

#Creates a blue image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
plt.imshow(x)

#Creates a yellow image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

#Creates a cyan image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,2] = 1
plt.imshow(x)

#Creates a pink image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,0] = 0.5
x[:,:,1] = 0.5
x[:,:,2] = 0.5
plt.imshow(x)

#Creates a gray image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,0] = 1
x[:,:,1] = 1
x[:,:,2] = 1
plt.imshow(x)

#Creates a white image by setting the red channel to maximum in a 2x2 array and displays it.

x = np.zeros((2,2,3))
x[:,:,0] = 0
x[:,:,1] = 0
x[:,:,2] = 0
plt.imshow(x)

#Creates a black image by setting the red channel to maximum in a 2x2 array and displays it.



r = np.random.rand()

#Generates a single random number between 0 and 1 using numpy's random function.

r



r = np.random.rand()
g = np.random.rand()
b = np.random.rand()


x = np.zeros((2,2,3))

x[:,:,0] = r
x[:,:,1] = g
x[:,:,2] = b


plt.imshow(x)

#Creates a 2x2 image with a random color by setting each channel (R, G, B) to random values.



for i in range(5):

    z = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    print(r,g,b)

    z[:,:,0] = r
    z[:,:,1] = g
    z[:,:,2] = b

    plt.imshow(z);
    plt.show()

    #Generates and displays 5 different 10x10 solid color images with random colors in a loop.





for i in range(5):

    z1 = np.ones((10,10,3))
    z2 = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    z1[:,:,0] = r
    z1[:,:,1] = g
    z1[:,:,2] = b

    z2[:,:,0] = 1-r
    z2[:,:,1] = 1-g
    z2[:,:,2] = 1-b

    z3 = np.hstack((z1,z2))

    plt.imshow(z3);
    plt.show()

    #Generates and displays 5 pairs of 10x10 images side by side with complementary colors using numpy and matplotlib in a loop.
    #Each pair consists of a random color image and its complementary image (where each color channel value is subtracted from 1 to get the complementary color), horizontally stacked together.



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2

z3 = np.hstack((z1,zavg,z2))

plt.imshow(z3);
plt.show()

#Creates and displays three 10x10 images side by side: two with random colors and one with their average color, using numpy and matplotlib.



z1 = np.ones((10,10,3))
z1[:,:,0] = np.random.rand()
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3))
z2[:,:,0] = np.random.rand()
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2

z1a = (z1+zavg)/2
z2a = (z2+zavg)/2

z3 = np.hstack((z1,z1a,zavg,z2a,z2))

plt.imshow(z3);
plt.show()

#Creates and displays a gradient of five 10x10 images side by side, transitioning from one random color to another through their averages, using numpy and matplotlib.





for i in range(100):

    z1 = np.ones((10,10,3))
    z1[:,:,0] = np.random.rand()
    z1[:,:,1] = np.random.rand()
    z1[:,:,2] = np.random.rand()

    z2 = np.ones((10,10,3))
    z2[:,:,0] = np.random.rand()
    z2[:,:,1] = np.random.rand()
    z2[:,:,2] = np.random.rand()

    zavg = (z1+z2)/2

    z1a = (z1+zavg)/2
    z2a = (z2+zavg)/2

    z3 = np.hstack((z1,z1a,zavg,z2a,z2))

    plt.imshow(z3);
    plt.show()

    #Generates 100 sequences of color gradients between two random colors using numpy and matplotlib.



import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):
    """
    Compute the recursive average of the given list of colors.

    Parameters:
    - colors: List of color arrays

    Returns:
    - A new list of color arrays containing the recursive averages.
    """
    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes):
    """
    Generate a visualization of 2 random colors and their recursive averages for a number of passes.

    Parameters:
    - passes: Number of times to apply the recursive averaging process

    Returns:
    - An image showing the 2 endpoint colors and their recursive averages.
    """
    # Start with 2 random colors
    colors = [np.ones((10,10,3)) for _ in range(2)]
    for color in colors:
        color[:,:,0] = np.random.rand()
        color[:,:,1] = np.random.rand()
        color[:,:,2] = np.random.rand()

    # Apply the recursive averaging for the specified number of passes
    for _ in range(passes):
        colors = recursive_average(colors)

    # Horizontally stack the colors
    result = np.hstack(colors)

    return result

    #Generates a visualization of color gradients with recursive averaging over multiple passes.

for i in range(5):
    img = generate_recursive_colors_v2(i)
    plt.imshow(img)
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    #Displays five images, each with increasing complexity of recursive color averages, without axes.

import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):

    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes, initial_colors):

    colors = initial_colors.copy()

    for _ in range(passes):
        colors = recursive_average(colors)

    result = np.hstack(colors)

    return result

initial_colors = [np.ones((10, 10, 3)) for _ in range(2)]
for color in initial_colors:
    color[:,:,0] = np.random.rand()
    color[:,:,1] = np.random.rand()
    color[:,:,2] = np.random.rand()

passes_values = [0,1,2,3,4]
imgs = [generate_recursive_colors_v2(p, initial_colors) for p in passes_values]

fig, axs = plt.subplots(1, len(passes_values), figsize=(15, 5))

for ax, img, p in zip(axs, imgs, passes_values):
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(f'Passes={p}')

plt.tight_layout()
plt.show()

#Generates and displays a series of images showing the effect of recursive color averaging across different numbers of passes, starting with two initial random colors.

"""https://lospec.com/palette-list"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib
import imageio.v2 as imageio
from PIL import Image

def get_colors_lospec(url):
    im = imageio.imread(url)
    rgb_list = (im/255)[0,:,0:3]
    float_list = list(np.linspace(0,1,len(rgb_list)))
    cdict = dict()
    for num, col in enumerate(['red', 'green', 'blue']):
        col_list = [[float_list[i], rgb_list[i][num], rgb_list[i][num]] for i in range(len(float_list))]
        cdict[col] = col_list
    cmp = mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256)
    return cmp

    #This function creates a custom matplotlib colormap from a palette image available at a given URL. It reads the image, extracts the RGB values of the first row, and constructs a colormap by linearly interpolating these colors.

url = 'https://lospec.com/palette-list/agb-32x.png'
im = imageio.imread(url)
plt.imshow(im);

#This code reads and displays the image from the specified URL using `imageio` and `matplotlib.pyplot`.

url = 'https://lospec.com/palette-list/agb-1x.png'
im = imageio.imread(url)
plt.imshow(im);

#Reads and displays an image from a given URL using `imageio` and `matplotlib`.

url = 'https://lospec.com/palette-list/moondrom-1x.png'
im = imageio.imread(url)
plt.imshow(im);

#This code snippet reads and displays the "moondrom" palette image from Lospec.

z = np.random.randint(0,255,size=(10,10))

#Generates a 10x10 array of random integers between 0 and 255 using numpy.

z

plt.imshow(z,cmap='jet')

#Displays the 10x10 array as an image using a 'jet' color map with matplotlib.

plt.imshow(z, cmap=get_colors_lospec(url))
plt.colorbar();

#Displays the 10x10 array as an image using a custom colormap from a Lospec URL and shows a color bar.

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]
z = np.sqrt(x**2 + y**2)

#Creates a meshgrid with coordinates from -5 to 5 and computes the radial distance \(z\) from the origin for each point.

x

y

z = np.sqrt(x**2 + y**2)

#Calculates the radial distance from the origin for each point in a 2D grid.

z.shape

plt.imshow(x)

#Plots the results of x

plt.imshow(y)

#Plots the results of y

z

#Plots the results of Z

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

#Displays the radial distance matrix \(z\) as an image, using a custom colormap created from a Lospec palette URL.



x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

#Displays a sine wave pattern along the \(y\)-axis using a custom colormap from a Lospec palette URL.

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

#Displays a sine wave pattern along the \(x\)-axis using a custom colormap from a Lospec palette URL.

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]

z = np.sin(3*y)*np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url));
plt.show()

#This code creates a 2D pattern by multiplying sine waves along both the \(x\) and \(y\) axes, then displays it using a custom colormap from a Lospec palette URL.



import matplotlib.pyplot as plt
import imageio
from PIL import Image
from skimage.io import imread

#This code imports `matplotlib.pyplot` for plotting, `imageio` and `skimage.io.imread` for image reading, and `PIL.Image` for advanced image processing tasks.

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

    #Defines a function to display a grayscale image `x` with no axis, in a large 20x20 inch figure.

im = imread('https://raw.githubusercontent.com/imageio/imageio-binaries/master/images/imageio_banner.png')

plot(im)

url = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Octopus2.jpg/800px-Octopus2.jpg"

#This code attempts to read an image from a URL using the imread function from skimage.io, aiming to load the ImageIO library banner image

im = imread(url)

#Loads an image from the URL into `im` using `skimage.io.imread`.

plot(im)

#Displays the image `im` in grayscale without axes, in a 20x20 inch figure.

im.shape

#Displays the shape of the image

plt.imshow(im[:,:,0],cmap="gray")

#The code simulates displaying the first channel of an image in grayscale using matplotlib, with axes hidden for clarity. ​

plt.imshow(im[:,:,1],cmap="gray")

#The code simulates displaying the second channel of an image in grayscale using matplotlib, with axes hidden for clarity. ​

plt.imshow(im[:,:,2],cmap="gray")

#The code simulates displaying the third channel of an image in grayscale using matplotlib, with axes hidden for clarity. ​

r = im[:,:,0]
g = im[:,:,1]
b = im[:,:,2]

combo = np.hstack([r,g,b])

#This code extracts the red, green, and blue channels from the image `im` into separate arrays `r`, `g`, and `b`, respectively.

plt.imshow(combo,cmap="gray")

#The code displays the placeholder image data as a grayscale image using matplotlib, with axes hidden for a cleaner appearance

