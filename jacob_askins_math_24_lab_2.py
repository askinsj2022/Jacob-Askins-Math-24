# -*- coding: utf-8 -*-
"""Jacob Askins Math 24 Lab 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CBzVikQ7M2-ljqW5YXa-16U2r_1Ej7N5
"""

import numpy as np
import matplotlib.pyplot as plt

#This code imports the NumPy library, which is used for numerical operations in Python, and the Matplotlib's pyplot module, which is used for creating static, interactive, and animated visualizations in Python.

numbers= np.array([1,2,2,3,3,3,4,4,4,4])

#Assigns an array to the numbers variable in assending value for the amount the number is (One 1, two 2, three 3)

plt.hist(numbers,100);

"""# PRNG"""

x = 0.12345

x = x*3

x % 1

#The code multiplies the decimal number 0.12345 by 3 and then calculates the remainder of this result when divided by 1.





import numpy as np
import matplotlib.pyplot as plt

x = 0.12345          # seed value
X = np.zeros(50000,)  # initialize an array of zeros

for i in range(X.shape[0]):
    x = 3*x % 1      # update x and store the value in X
    X[i] = x

plt.plot(X, '.')     # plot the values in X
plt.show()
#This code initializes a seed value x, creates an array X of 50,000 zeros, iteratively updates x using a chaotic map equation and stores each new value in X, then plots these values as a series of points.

plt.hist(X);

#alternative way to display information

def coin():
    return 2*(np.random.random() > 0.5) - 1

#creates a "Coin" to represent heads or tails

coin()
#prints coin

x = 0
x + coin()

x = 0

for i in range(3):
    x = x + coin()

    #The code increments the variable x by the result of the coin() function, which will either add 1 or subtract 1 from x, simulating a coin flip outcome.

x

x = 0

for i in range(100):
    x = x + coin()

    #runs the previous code for n amount of times, in this case it's 100 times in a for loop

x

M = 10000
N = 100

X = np.zeros(M,)

for j in range(M):

    x = 0

    for i in range(N):
        x = x + coin()

    X[j] = x

    #This code simulates a process of flipping a coin 100 times, repeated 10,000 times, and stores the cumulative sum of each 100-flip series in an array X. Each entry in X represents the net result (sum of 1s and -1s) of 100 coin flips.

plt.hist(X,100);

#displays the plot, this is also a "bell curve"



"""# Bonus: Explain Pascal's Triangle"""

P = np.zeros((12,18))

P[0,5]=1

for i in range(1,P.shape[0]):

    for j in range(1,P.shape[1]-1):

        P[i,j] = P[i-1,j-1]+P[i-1,j]

print(P[:,5:])

#The code creates a 12x18 matrix, initializes one value, and fills it using a rule resembling Pascal's triangle. Prints part of the matrix.

"""# Normal Distribution"""

# Define the parameters for the normal distribution
mean = 0  # Mean (mu) of the distribution
std_dev = 0.1  # Standard deviation (sigma) of the distribution

# Generate 1000 data points following a normal distribution with the specified mean and standard deviation
sample_size = 1000
data_points = np.random.normal(mean, std_dev, sample_size)

# Plot the histogram of the data points
bins_number = 30  # Number of bins for the histogram
hist_count, x, ignored = plt.hist(data_points, bins_number, density=True)

# Plot the probability density function of the normal distribution
normal_dist_curve = 1 / (std_dev * np.sqrt(2 * np.pi)) * np.exp(- (x - mean) ** 2 / (2 * std_dev ** 2))
plt.plot(x, normal_dist_curve, linewidth=2, color='r')

# Set the title and labels for the plot
plt.title('Normal Distribution Visualization')
plt.xlabel('Value')
plt.ylabel('Probability Density')

# Display the plot
plt.show()

#Generates a histogram of 1000 points from a normal distribution and overlays its probability density function.

x = np.array([1,2,3,4])

#Creates a NumPy array x containing the elements 1, 2, 3, and 4.

np.sum(x)

#Calculates and returns the sum of elements in the NumPy array x.

x.shape[0]

#Returns the number of elements in the first dimension of the array x.

np.sum(x)/x.shape[0]

#Calculates and returns the average of the elements in the array x.

def mean(x):
    return np.sum(x)/x.shape[0]

    #Defines a function mean to calculate the average of elements in array x.

mean(x)

#Prints the mean of x.

x

#prints the x array.

x - mean(x)

#subtracts the mean of x from the array of x.

(x - mean(x))**2

#subtracts the mean of x from x and squares the array afterwards.

def var(x):
    return mean((x - mean(x))**2)

    #Defines a function var to calculate variance of elements in array x.

def std(x):
    return np.sqrt(var(x))

    #Defines a function std to calculate standard deviation of array x elements

mean(x)

#Displays the mean of x

var(x)

#displays the variation of x

std(x)

#displays the standard deviation of x



"""### Uniform Random Numbers"""

X = np.random.random(500000,)

#creates an array between 0 and 1 with n amount of units (500000)

X

#prints x

plt.hist(X,100);

#Displays a histogram of array X with 100 bins.

np.random.random()

#creates a random number between 1 and 0

r = np.random.random()

#assigns a random value from 0 to 1 for r

r

#Prints r

r = np.random.randint(1,10)

#assigns a random number between 1 and 10 as a whole number

r

#print r

np.random.randn()

#random number generator

numbers  = np.random.randn(2,4)

#Creates a 2x4 array 'numbers' with random numbers from a standard normal distribution

numbers.shape

#Returns the shape of the array 'numbers'

numbers = numbers.reshape(-1)

#Reshapes 'numbers' into a 1D array, inferring the length automatically.

numbers.shape

#Returns the shape of the reshaped 1D array 'numbers'.

numbers= np.array([1,2,2,3,3,3,4,4,4,4])

#Creates a NumPy array 'numbers' with specified integer elements.

plt.hist(numbers,100);

#Displays a histogram of 'numbers' with 100 bins.

numbers = np.random.randn(100000,)
plt.hist(numbers,100);

#Displays a histogram of 100,000 normally distributed random numbers with 100 bins.

numbers = np.random.rand(1000000,)
plt.hist(numbers,100);

#Displays a histogram of 1,000,000 uniformly distributed random numbers with 100 bins.

np.random.seed(12345)
data = np.random.randn(2, 100)

plt.figure(1, figsize=(9, 9))

plt.subplot(2,2,1)
plt.hist(data[0])

plt.subplot(2,2,2)
plt.scatter(data[0], data[1])

plt.subplot(2,2,3)
plt.plot(data[0], data[1],'-')

plt.subplot(2,2,4)
plt.hist2d(data[0], data[1])

plt.show()

#Generates and displays four plots: two histograms, a scatter plot, and a 2D histogram of 2x100 normally distributed data points.

"""Normal Dist Data"""

x = 10*np.random.randn(10000)

#Creates an array 'x' with 10,000 random numbers from a normal distribution, scaled by 10.

plt.hist(x);

#Displays a histogram of the array 'x'.

x = np.random.rand(1000,)

#Creates an array 'x' with 1000 random numbers uniformly distributed between 0 and 1.

plt.hist(x);

#Plots a histogram of the array of x



mu = 100  # mean of distribution
sigma = 15  # standard deviation of distribution
x = mu + sigma * np.random.randn(10000)

#Creates an array 'x' with 10,000 random numbers from a normal distribution centered at 100 with a standard deviation of 15.

n,bins,patches = plt.hist(x,bins=100)

#Displays a histogram of 'x' with 100 bins, capturing bin data in variables 'n', 'bins', 'patches'.

bins

#prints bins

y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(y)

#Makes a line plot of y

num_bins = 50
n,bins,patches = plt.hist(x, num_bins, density=1)
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2))
plt.plot(bins,y)

#Displays normalized histogram of 'x' and overlays the corresponding normal distribution curve.



x

#prints x

def mean(x):
    return np.sum(x)/x.shape[0]

    #Defines function mean to calculate average of elements in array x.

def var(x):
    return mean((x - mean(x))**2)

    #

def std(x):
    return np.sqrt(var(x))

    #Defines function var to calculate variance of elements in array x.

def median(x):
    n = len(x)
    sorted_x = np.sort(x)
    mid = n // 2
    if n % 2 == 0:
        return (sorted_x[mid - 1] + sorted_x[mid]) / 2
    else:
        return sorted_x[mid]

        #Defines function median to calculate median of elements in array x.

def mode(x):
    values, counts = np.unique(x, return_counts=True)
    max_count_index = np.argmax(counts)
    return values[max_count_index]

    #Defines function mode to find most frequent element in array x.

def range(x):
    return np.max(x) - np.min(x)

    #Defines function range to calculate difference between max and min in array x

data = np.array([1, 2, 2, 3, 4, 5, 5, 5, 6])

# Testing the functions
mean_value = mean(data)
var_value = var(data)
std_value = std(data)
median_value = median(data)
mode_value = mode(data)
range_value = range(data)

mean_value, var_value, std_value, median_value, mode_value, range_value

#Calculates statistical measures for given data array



"""# Homework



"""



"""# Pi from Random Numbers"""

N = 10000

#creating a variable

points = -1 + 2*np.random.random((N,2))

#Creates an N by 2 array points with random values ranging from -1 to 1.

plt.plot(points[:,0],points[:,1],'.')

plt.gca().set_aspect(1)

#Plots points from array, sets plot aspect ratio to 1 for equal scaling.

inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1
outside_circle = points[:,0]**2 + points[:,1]**2  > 1

plt.plot(points[inside_circle,0],points[inside_circle,1],'g.')
plt.plot(points[outside_circle,0],points[outside_circle,1],'r.')


plt.gca().set_aspect(1)

#Separates points inside and outside a unit circle, plots them in green and red, and sets aspect ratio to 1.

np.sum(inside_circle),np.sum(outside_circle)

#Calculates count of points inside and outside the unit circle.

total_area = 4

#Creates a variable for total area or plot

fraction_inside = np.sum(inside_circle)/N

#Calculates fraction of points inside the unit circle relative to total N.

fraction_inside*total_area

N = 100000000
points = -1 + 2*np.random.random((N,2))
inside_circle  = points[:,0]**2 + points[:,1]**2  <=  1
fraction_inside = np.sum(inside_circle)/N
fraction_inside*4

#Estimates pi with 100 million random points

"""# Complete Code for Estimating π using Monte Carlo Simulation"""

# Number of random points to generate
num_points = 10000

# Generating random points
x_points = np.random.uniform(-1, 1, num_points)
y_points = np.random.uniform(-1, 1, num_points)

# Calculating the number of points inside the quarter circle
points_inside = np.sqrt(x_points**2 + y_points**2) <= 1
num_inside = np.sum(points_inside)

# Estimating π
pi_estimate = 4 * num_inside / num_points

# Plotting the points and the quarter circle
plt.figure(figsize=(6, 6))
plt.scatter(x_points[points_inside], y_points[points_inside], color='green', label='Inside')
plt.scatter(x_points[~points_inside], y_points[~points_inside], color='red', label='Outside')
circle = plt.Circle((0, 0), 1, color='blue', fill=False)
plt.gca().add_artist(circle)
plt.title('Estimating π using Monte Carlo Simulation')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.axis('equal')
plt.show()

pi_estimate

#Completed code from previous section





"""# e from Random Numbers"""

X = np.random.random((1000000,10))

#Creates a 1,000,000 by 10 array X with random numbers between 0 and 1.

Y = np.cumsum(X,1)

#Calculates sum of X along its second axis, storing results in Y

Z = np.argmax(Y > 1,1) + 1

#Finds where cumulative sum in each row of Y exceeds 1, stores in Z

np.mean(Z)

#Calcualtes the average of the values in array Z

np.mean(np.argmax(np.cumsum(np.random.random((10000000,10)),1) > 1,1) + 1)

#Calculates the average of first indices where cumulative sums in a large random array exceed 1.

np.exp(1)

#Calculates the mathematical constant e (Euler's number) raised to the power of 1





"""# Further Reading:

### Quantum Random Numbers API

https://aws.amazon.com/marketplace/pp/prodview-246kyrfjo3bag
"""



