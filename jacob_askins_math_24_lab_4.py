# -*- coding: utf-8 -*-
"""Jacob Askins Math 24 Lab 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cZ6XC9Ajffm27FhvuShdFa0o16SFd7yf

#Monte Carlo
"""

import numpy as np
import matplotlib.pyplot as plt

#These lines import the NumPy library as np and the Matplotlib's pyplot module as plt, enabling numerical operations and plotting capabilities in Python.

x = np.linspace(-3,3,100)

#This line creates an array `x` with 100 evenly spaced values between -3 and 3, inclusive.

y = x**2 + 2

#This line calculates y as the square of each element in x plus 2, creating a parabolic curve

plt.plot(x,y)



"""$f(x) = x^2 + 2$

$Area = \int_a^bf(x) dx$

$= \int_a^b (x^2+2) dx$

$= \left.\frac{x^3}{3}+2x\right\vert_1^2$

$= (\frac{8}{3}+4) - (\frac{1}{3}+2)$

$= \frac{13}{3}$
"""

13/3

"""To integrate the function $f(x)$ over the interval $[a,b]$ we

[1] find some value $M$ such that $f(x) < M$ over the interval $[a,b]$

[2] select a random number $x$ from a uniform distribution over the interval $[a,b]$

[3] select a random number y from a uniform distribution over the interval $[0,M]$

[4] determine if $y > f(x)$ or $y ≤ f(x)$

[5] repeat this process $N$ times, keeping track of the number of times $y ≤ f(x)$ or under the curve, successes $S$.

The estimated probability of success is then:

$\frac{S}{N}=\frac{\text{Area under curve}}{\text{Total area inside rectangle}} = \frac{\int_a^bf(x)dx}{M(b-a)}$

$\int_a^bf(x)dx = M(b-a)\frac{S}{N}$
"""

def f(x):
    y = x**2 + 2
    return y
#This function `f` takes an input `x`, computes `y` as the square of `x` plus 2, and returns `y`.

plt.plot(x,f(x))

#This line plots the function `f(x)` over the range of `x`, creating a graph of the parabola \(y = x^2 + 2\).



M = 10

#This line sets the variable M to the value 10.

a = 1
b = 2

#This line sets the variable a and b to the value 1 and 2.

x = a + (b-a)*np.random.random()

#This line generates a random number `x` within the range `[a, b)` using a uniform distribution, where `a` and `b` are the lower and upper bounds.

x

#displays x

y = M*np.random.random()

#This line generates a random number y in the range [0, M) using a uniform distribution, where M is the maximum possible value.

x,y,f(x)

#This displays the x, y, and f(x) variables.

y < f(x)

N = 100_000
S = 0
for i in range(N):

    x = a + (b-a)*np.random.random()
    y = M*np.random.random()

    S += (y < f(x))

M*(b-a)*(S/N)

#This code estimates the area under f(x) = x^2 + 2 on [a, b] using Monte Carlo integration. By generating N points in a rectangle spanning a to b and 0 to M, it calculates the area proportionally, based on points under f(x).





def f(x):
    y = x**2 + 2
    return y
#Defines function `f(x)` that returns `x` squared plus 2.

def monte_carlo_integrate(f,a,b,N):

    N = 10000000
    S = 0
    for i in range(N):

        x = a + (b-a)*np.random.random()
        y = M*np.random.random()

        S += (y < f(x))

    return M*(b-a)*(S/N)
#This function monte_carlo_integrate estimates the integral of f(x) from a to b using Monte Carlo simulation with N = 10,000,000 samples. It calculates the area under f(x) by generating random points within a defined rectangle and checking if they fall under the curve.

monte_carlo_integrate(f,1,2,1000)
#This line calls monte_carlo_integrate with the function f(x) = x^2 + 2, interval [1, 2], and N = 1000.

from sympy import *

#This line imports all functions and classes from the sympy library, which is used for symbolic mathematics

x = Symbol('x')

#This line defines `x` as a symbol, allowing it to be used in symbolic expressions and equations with the `sympy` library.

x

integrate(x**2 + 2, (x,1,2))

13/3

integrate(x**3 + 3, (x,1,2))

#This line calculates the definite integral of the function \(x^2 + 2\) from \(x = 1\) to \(x = 2\) symbolically, providing the exact area under the curve in this interval.

27/4

x = 0

def f(x):
    y = x**3 + 3
    return y

#Redefines the function `f(x)` to return `x` cubed plus 3.



N = 2000
S = 0
Z = np.zeros(N,)
for i in range(1,N):

    x = a + (b-a)*np.random.random()
    y = M*np.random.random()

    S += (y < f(x))

    Z[i] = M*(b-a)*(S/i)

#This code estimates the integral of `f(x) = x^3 + 3` from `a` to `b` using Monte Carlo integration with `N = 2000` iterations. It calculates the cumulative estimate of the integral after each iteration and stores these estimates in the array `Z`.

plt.plot(Z)
plt.plot(6.75*np.ones(Z.shape))
#This code plots the cumulative estimates of the integral (stored in Z) as the Monte Carlo simulation progresses. It also plots a horizontal line at y = 6.75, representing the expected value of the integral if known or calculated separately



import numpy as np
import matplotlib.pyplot as plt
from sympy import Symbol, integrate

# Define a general function for Monte Carlo integration
def monte_carlo_integrate(func, a, b, N, M):
    S = 0
    for _ in range(N):
        x = a + (b - a) * np.random.random()
        y = M * np.random.random()
        if y < func(x):
            S += 1
    return M * (b - a) * (S / N)

# Define the functions to be integrated
def f1(x):
    return x**2 + 2

def f2(x):
    return x**3 + 3

# Calculate exact and estimated areas
def calculate_areas(func, a, b, N, M):
    x_sym = Symbol('x')
    exact_area = integrate(func(x_sym), (x_sym, a, b)).evalf()
    estimated_area = monte_carlo_integrate(func, a, b, N, M)
    return exact_area, estimated_area

# Plotting function
def plot_function(func, title, a=-3, b=3):
    x = np.linspace(a, b, 100)
    y = func(x)
    plt.plot(x, y, label=title)
    plt.title(title)
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.legend()
    plt.show()

# Plot the functions
plot_function(f1, "$f(x) = x^2 + 2$")
plot_function(f2, "$f(x) = x^3 + 3$")

# Calculate and print areas
exact_area_f1, estimated_area_f1 = calculate_areas(f1, 1, 2, 100000, 20)
exact_area_f2, estimated_area_f2 = calculate_areas(f2, 1, 2, 1000000, 20)

print("Exact Area under f1:", exact_area_f1)
print("Estimated Area under f1:", estimated_area_f1)
print("Exact Area under f2:", exact_area_f2)
print("Estimated Area under f2:", estimated_area_f2)


#This code estimates the areas under two functions, using the Monte Carlo method and compares these estimates with exact areas obtained via symbolic integration. It visualizes the functions over a specified interval and prints both the exact and estimated areas for each function.





"""# Visualization"""

# Function to plot points for Monte Carlo integration
def plot_monte_carlo(func, a, b, M, N):
    x_points = a + (b - a) * np.random.random(N)
    y_points = M * np.random.random(N)
    below = y_points < func(x_points)
    above = np.invert(below)

    # Plotting the function
    x = np.linspace(a - 1, b + 1, 400)
    y = func(x)
    plt.plot(x, y, label="f(x)", color='black')

    # Plotting the points
    plt.scatter(x_points[below], y_points[below], color='green', label='Points below f(x)')
    plt.scatter(x_points[above], y_points[above], color='red', label='Points above f(x)')

    # Setting up the plot limits and labels
    plt.xlim(a - 1, b + 1)
    plt.ylim(0, M)
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("Monte Carlo Integration Visualization")
    plt.legend()

    plt.show()

# Function to be integrated
def f(x):
    return x**2 + 2

# Parameters for Monte Carlo Integration
a, b, M, N = 1, 2, 20, 1000

# Plotting the Monte Carlo Integration
plot_monte_carlo(f, a, b, M, N)

#This code visualizes Monte Carlo integration by plotting random points within a defined rectangle to estimate the area under the line. Points below the function are colored green, above are red, and the function itself is plotted in black, illustrating the method's principle.



# Function for Monte Carlo Integration
def monte_carlo_integrate(func, a, b, N, M):
    S = 0
    for _ in range(N):
        x = a + (b - a) * np.random.random()
        y = M * np.random.random()
        if y < func(x):
            S += 1
    return M * (b - a) * (S / N)

# Function to be integrated
def f(x):
    return x**2 + 2

# Parameters
a, b, M = 1, 2, 20
iterations = np.logspace(1, 6, 100, dtype=int)  # Using logarithmically spaced iterations for smoother curve
estimated_areas = []

# Calculate estimated areas for different numbers of iterations
for N in iterations:
    estimated_area = monte_carlo_integrate(f, a, b, N, M)
    estimated_areas.append(estimated_area)

# Plotting convergence
plt.figure(figsize=(10, 6))
plt.plot(iterations, estimated_areas, color='blue')
plt.xscale('log')
plt.xlabel('Number of Iterations (log scale)')
plt.ylabel('Estimated Area')
plt.title('Convergence of Monte Carlo Integration')
plt.grid(True)
plt.show()



